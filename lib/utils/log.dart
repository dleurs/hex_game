import 'dart:async';
import 'dart:developer';

class Log {
  /// Current Log Level for the entire app
  static LogLevel logLevel = LogLevel.ALL;

  /// Current log level for which the stack trace will be auto-generated if not specified
  static LogLevel stackTraceLevel = LogLevel.OFF;

  /// Tag that identifies this app in logs
  static const _TAG = 'chanel-me';

  Log._privateConstructor();

  ///
  /// Prints a verbose [message].
  ///
  static void verbose(String message) {
    _doLog(LogLevel.VERBOSE, message);
  }

  ///
  /// Prints a debug [message].
  ///
  static void debug(String message) {
    _doLog(LogLevel.DEBUG, message);
  }

  ///
  /// Prints an informative [message].
  ///
  static void info(String message) {
    _doLog(LogLevel.INFO, message);
  }

  ///
  /// Prints a warning [message] along with the original [error] that was thrown
  /// and the [stackTrace] at the time if specified.
  ///
  static void warn(String message, {Object? error, StackTrace? stackTrace}) {
    _doLog(LogLevel.WARNING, message, error: error, stackTrace: stackTrace);
  }

  ///
  /// Prints an error [message] along with the original [error] that was thrown
  /// and the [stackTrace] at the time if specified.
  ///
  static void error(String message, {Object? error, StackTrace? stackTrace}) {
    _doLog(LogLevel.ERROR, message, error: error, stackTrace: stackTrace);
  }

  ///
  /// Prints a logging [message] only if the log [level]
  /// is greater than or equal to the global [logLevel] parameter
  ///
  static void _doLog(LogLevel level, String message,
      {Object? error, StackTrace? stackTrace}) {
    StackTrace finalStackTrace = StackTrace.current; // not sure
    if (level.value >= stackTraceLevel.value) {
      finalStackTrace = stackTrace ?? StackTrace.current;
      error ??= 'at autogenerated stack trace';
    }
    if (level.value >= logLevel.value) {
      log(message,
          name: '${level.name}/ $_TAG',
          level: level.value,
          error: error,
          stackTrace: finalStackTrace,
          time: DateTime.now(),
          zone: Zone.current);
    }
  }
}

enum LogLevel { ALL, VERBOSE, DEBUG, INFO, WARNING, ERROR, OFF }

extension LogLevelExtension on LogLevel {
  int get value {
    switch (this) {
      case LogLevel.ALL:
        return 0;
      case LogLevel.VERBOSE:
        return 300;
      case LogLevel.DEBUG:
        return 500;
      case LogLevel.INFO:
        return 800;
      case LogLevel.WARNING:
        return 900;
      case LogLevel.ERROR:
        return 1000;
      case LogLevel.OFF:
        return 2000;
      default:
        return 0;
    }
  }

  String get name {
    switch (this) {
      case LogLevel.VERBOSE:
        return 'VERBOSE';
      case LogLevel.DEBUG:
        return 'DEBUG';
      case LogLevel.INFO:
        return 'INFO';
      case LogLevel.WARNING:
        return 'WARNING';
      case LogLevel.ERROR:
        return 'ERROR';
      default:
        return '';
    }
  }
}
